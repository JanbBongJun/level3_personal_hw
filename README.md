# level 3 personal hw

1. Q: `mongoose`에서 `sequelize`로 변경했을 때, 많은 코드 변경이 있었나요? 있었다면 어떤 코드에서 변경사항이 많았나요?

   A: mongoose에서 squelize로 변경했을 때 데이터를 받아오는 부분을 제외하고 변경이 많이 없었던 것 같습니다. 또한, MongoDB를 이용했을 때는 schema폴더를 만들었었다면,
   sequelize로 변경했을 때는 migrations와 models를 작성하여 스키마와 외래키 관계를 지정해 주는 것 외에는 특별히 변경이 필요 없었던 것 같습니다.

2. Q: 닉네임과 비밀번호에 대한 요구사항 검증은 어떻게 진행하였나요? 만약 정규표현식을 사용하였다면 어떤 정규표현식으로 구현하였나요?

   A: 회원가입 중 닉네임과 비밀번호에 대한 요구사항 검증은 과제의 요구사항에 맞도록 작성하였습니다.

   닉네임의 경우 정규식을 뜯어보면,
   ^[a-zA-Z0-9]{3,}$
   ^과 $의 경우 시작과 끝을 나타내며 그 사이에 a~z, A~Z, 0~9로 이루어진 문자열로 구성되며, [a-zA-Z0-9]안에 포함된 문자열이 3번이상 반복되기 위해서 ,를 찍었습니다.

   패스워드의 경우
   길이가 4보다 작거나, confirm과 password가 일치하지 않는경우, indexOf를 통해 password에 닉네임이 포함된 경우를 판단하여 처리하였습니다.
   또한, 회원가입중에 어떤 부분이 잘못됬는지를 각각 전달해주기 위해 &&연산자를 이용하지 않고, 조건문을 통해서 구현하였습니다.

3. Q: ERD를 먼저 작성 후 개발을 진행했을 때, 좋은점은 어떤것들이 있었나요?

   A: ERD를 먼저 작성 후 개발을 진행했을 때, DB의 테이블간 외래키 관계를 한눈에 파악하기 쉬웠으며, 쿼리문을 찍어보지 않고도, 한눈에 DB의 필드를 파악할 수 있었습니다.

   또한, 개발 초기단계에 어떤 데이터를 db에 저장하고, 가공할지를 고민하게되기 때문에 후에 db의 migration과 model을 수정할 일이 없었던 것 같습니다.

4. Q: JWT를 이용해 사용자 인증은 진행하였을 때, 어떤 장점과 단점이 존재하였나요?

   A: JWT를 이용하게되는경우 손쉽게 사용자 정보를 암호화 하여 사용자 권한을 인증할 수 있다는 점이 장점같습니다. 또한, 토큰이 존재하지 않는다면 사용자 인증이 필요한 기능을 이용하려 할때마다 로그인을 진행해야 하기때문에 사용자 경험이 저해됩니다.

   서비스중 절대 그러면 안되지만, 서버가 잠시 멈춰도 사용자는 해당 토큰을 계속 이용할 수 있습니다.

   토큰이 탈취당했을 경우 심각한 문제가 발생할 수 있습니다.

   또한, 서버에서 사용하는 키가 유출되었을 때 보안 문제를 초래할 수 있습니다.

   이러한 문제를 해결하기 위해서는
   상대적으로 유효기간이 긴 Refresh Token과 기간이 짧은 Access Token을 분리하여, 클라이언트에 전달되는 Access Token이 탈취되더라도, 토큰이 만료되는 기간을 짧게하여 피해를 줄일 수 있습니다.

5. Q: **게시글 조회 API** Response를 어떻게 구성하였나요? 왜 그렇게 구성하였나요?
    A: response를 정상적으로 db에서 데이터를 받아와 반환하였을 때와 오류가 발생했을 때로 나누었다. 정상적으로 반환되었을 때 200번의 status를 전달할 수 있도록 하였으며, 데이터베이스와 연결 오류가 발생했을 때는 500번을 활용하였다. 


6. Q: **게시글 조회 API** 를 어떻게 구성하였나요? 왜 그렇게 구성하였나요?
   A: 우선 게시글 조회 API에 string query를 받아올 수 있도록 하여 페이지 넘버와 페이지에 들어갈 수 있는 데이터 수를 받아올 수 있도록 하였다. <pageNum,pageSize>
   이를 findAll을 통해서 받아오는 과정에서 limit와 offset옵션을 활용하여 원하는 데이터 갯수와
   몇 번 데이터부터 보낼지를 지정하였다. ex: 10번째 데이터부터 4개전달

   게시글 조회 api에서 findAll을 사용하여, Posts 테이블의
   ["postId", "UserId", "title", "createdAt", "updatedAt"]에 대한필드를 가져올 수 있도록 하였으며,
   외래키관계를 활용하여, Users테이블의 nickname을 가져올 수 있도록하여, 클라이언트가 해당 nickname을 가진 유저가 게시글을 작성했다는 것을 알 수 있도록 하였다.

   또한, 작성된 게시글이 없을때 빈 배열을 반환하도록 하였다.
   마지막으로, 서버와 db의 요청과 응답을 처리하는 부분을 try catch로 묶어
   데이터베이스와 연결오류가 발생했을 때 서버가 종료되지 않도록 처리하였다.

   7. Q: **게시글 생성 API** 를 어떻게 구성하였나요? 왜 그렇게 구성하였나요?
      A: title 과 content를 클라이언트가 입력하지 않은 경우 에러처리를 해주었으며,
      데이터를 create하는데 실패하면 오류가 발생하므로 try-catch를 통해서 에러를 처리하였다.
